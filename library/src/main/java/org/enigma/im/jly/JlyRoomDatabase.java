package org.enigma.im.jly;

import android.database.Cursor;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import androidx.room.Database;
import androidx.room.InvalidationTracker;
import androidx.room.PrimaryKey;
import androidx.room.RoomDatabase;
import androidx.room.migration.Migration;
import androidx.sqlite.db.SupportSQLiteDatabase;
import androidx.sqlite.db.SupportSQLiteOpenHelper;
import androidx.sqlite.db.SupportSQLiteQuery;
import androidx.sqlite.db.SupportSQLiteStatement;

import java.util.concurrent.Callable;
import java.util.concurrent.Executor;

/**
 * author:  hedongjin
 * date:  2019-06-03
 * description: Please contact me if you have any questions
 */
public abstract class JlyRoomDatabase {

    private static final String DB_JLY_SUFFIX = "_Jly";
    private RoomDatabase db;

    public JlyRoomDatabase(RoomDatabase db) {
        this.db = db;
    }



    /**
     * Returns the SQLite open helper used by this database.
     *
     * @return The SQLite open helper used by this database.
     */
    @NonNull
    public SupportSQLiteOpenHelper getOpenHelper() {
        return db.getOpenHelper();
    }



    /**
     * Deletes all rows from all the tables that are registered to this database as
     * {@link Database#entities()}.
     * <p>
     * This does NOT reset the auto-increment value generated by {@link PrimaryKey#autoGenerate()}.
     * <p>
     * After deleting the rows, Room will set a WAL checkpoint and run VACUUM. This means that the
     * data is completely erased. The space will be reclaimed by the system if the amount surpasses
     * the threshold of database file size.
     *
     * @see <a href="https://www.sqlite.org/fileformat.html">Database File Format</a>
     */
    @WorkerThread
    public void clearAllTables() {
        db.clearAllTables();
    }

    /**
     * Returns true if database connection is open and initialized.
     *
     * @return true if the database connection is open, false otherwise.
     */
    public boolean isOpen() {
        return db.isOpen();
    }

    /**
     * Closes the database if it is already open.
     */
    public void close() {
        db.close();
    }


    public Cursor query(String query, @Nullable Object[] args) {
        return db.query(query, args);
    }

    /**
     * Wrapper for {@link SupportSQLiteDatabase#query(SupportSQLiteQuery)}.
     *
     * @param query The Query which includes the SQL and a bind callback for bind arguments.
     * @return Result of the query.
     */
    public Cursor query(SupportSQLiteQuery query) {
        return db.query(query);
    }

    /**
     * Wrapper for {@link SupportSQLiteDatabase#compileStatement(String)}.
     *
     * @param sql The query to compile.
     * @return The compiled query.
     */
    public SupportSQLiteStatement compileStatement(@NonNull String sql) {
        return db.compileStatement(sql);
    }

    /**
     * Wrapper for {@link SupportSQLiteDatabase#beginTransaction()}.
     */
    public void beginTransaction() {
        db.beginTransaction();
    }

    /**
     * Wrapper for {@link SupportSQLiteDatabase#endTransaction()}.
     */
    public void endTransaction() {
        db.endTransaction();
    }

    /**
     * @return The Executor in use by this database for async queries.
     */
    @NonNull
    public Executor getQueryExecutor() {
        return db.getQueryExecutor();
    }

    /**
     * Wrapper for {@link SupportSQLiteDatabase#setTransactionSuccessful()}.
     */
    public void setTransactionSuccessful() {
        db.setTransactionSuccessful();
    }

    /**
     * Executes the specified {@link Runnable} in a database transaction. The transaction will be
     * marked as successful unless an exception is thrown in the {@link Runnable}.
     *
     * @param body The piece of code to execute.
     */
    public void runInTransaction(@NonNull Runnable body) {
        db.runInTransaction(body);
    }

    /**
     * Executes the specified {@link Callable} in a database transaction. The transaction will be
     * marked as successful unless an exception is thrown in the {@link Callable}.
     *
     * @param body The piece of code to execute.
     * @param <V>  The type of the return value.
     * @return The value returned from the {@link Callable}.
     */
    public <V> V runInTransaction(@NonNull Callable<V> body) {
        return db.runInTransaction(body);
    }
    /**
     * Returns the invalidation tracker for this database.
     * <p>
     * You can use the invalidation tracker to get notified when certain tables in the database
     * are modified.
     *
     * @return The invalidation tracker for the database.
     */
    @NonNull
    public InvalidationTracker getInvalidationTracker() {
        return db.getInvalidationTracker();
    }

    /**
     * Returns true if current thread is in a transaction.
     *
     * @return True if there is an active transaction in current thread, false otherwise.
     * @see SupportSQLiteDatabase#inTransaction()
     */
    @SuppressWarnings("WeakerAccess")
    public boolean inTransaction() {
        return db.inTransaction();
    }

    public static class Builder<J extends JlyRoomDatabase, R extends RoomDatabase> {

        private Class<J> jClass;
        private Class<R> rClass;
        private RoomDatabase.Builder<R> builder;

        public Builder(Class<J> jClass, Class<R> rClass, RoomDatabase.Builder<R> builder)  {
            this.jClass = jClass;
            this.rClass = rClass;
            this.builder = builder;
        }

        public Builder<J, R> openHelperFactory(@Nullable SupportSQLiteOpenHelper.Factory factory) {
            builder.openHelperFactory(factory);
            return this;
        }


        @NonNull
        public Builder<J, R> addMigrations(@NonNull  Migration... migrations) {
            builder.addMigrations(migrations);
            return this;
        }


        @NonNull
        public Builder<J, R> allowMainThreadQueries() {
            builder.allowMainThreadQueries();
            return this;
        }


        @NonNull
        public Builder<J, R> setJournalMode(@NonNull RoomDatabase.JournalMode journalMode) {
            builder.setJournalMode(journalMode);
            return this;
        }

        @NonNull
        public Builder<J, R> setQueryExecutor(@NonNull Executor executor) {
            builder.setQueryExecutor(executor);
            return this;
        }


        @NonNull
        public Builder<J, R> fallbackToDestructiveMigration() {
            builder.fallbackToDestructiveMigration();
            return this;
        }

        @NonNull
        public Builder<J, R> fallbackToDestructiveMigrationFrom(int... startVersions) {
            builder.fallbackToDestructiveMigrationFrom(startVersions);
            return this;
        }


        @NonNull
        public Builder<J, R> addCallback(@NonNull RoomDatabase.Callback callback) {
            builder.addCallback(callback);
            return this;
        }

        public J build() {
            return Jly.getGeneratedImplementation(jClass, DB_JLY_SUFFIX, rClass, builder.build());
        }
    }
}
